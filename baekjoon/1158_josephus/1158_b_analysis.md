# BOJ 1158 - 요세푸스 문제 - 문제 해석

## 문제 설명

- 1부터 N번까지 사람이 원을 이루고 앉아 있다.
- 순서대로 K번째 사람을 제거한다.
- 제거된 사람은 다시 포함되지 않고, 남은 사람들로만 계속 진행한다.
- 모든 사람이 제거될 때까지 순서를 반복하며,
- 제거된 순서를 `< >`로 출력한다.
- K는 1 이상 N 이하의 값이고, N은 최대 5000까지 가능

## 입력

- 첫 줄: N과 K (정수, 공백으로 구분)
  - N: 사람 수
  - K: 제거할 간격

## 출력

- 제거된 사람의 번호를 제거 순서대로 출력
- 출력 형식: `<a, b, c, ...>`

## 예제 입력

7 3

## 예제 출력

<3, 6, 2, 7, 5, 1, 4>

## 풀이 요약

### 방법 1: Queue 방식

- 1~N까지 배열에 넣은 후,
- 앞에서부터 K번째 사람을 제거하고,
- 제거되지 않은 사람은 다시 배열 끝에 push
- count로 몇 번째 사람인지 추적
- 제거된 순서를 결과 배열에 담아 출력

### 방법 2: 인덱스 기반 방식 (splice 활용)

- 배열에서 인덱스를 K만큼 이동하며 제거
- `index = (index + k - 1) % 배열길이`로 원형 이동 처리
- 제거된 사람을 splice로 꺼내고 결과에 저장

## 시간 복잡도

- 둘 다 최악의 경우 O(N²) 가능하지만  
  N ≤ 5,000이므로 충분히 통과 가능

---

## 📌 개념 정리: Queue(큐)란?

- **FIFO (First In, First Out)**  
  → 먼저 들어온 게 먼저 나간다.
- 줄 서는 구조: 선착순 입장 → 입장한 순서대로 퇴장

**대표적인 동작**

- `push()` → 뒤에 넣기
- `shift()` → 앞에서 꺼내기

---

## ✍️ 풀이 회고 (by 헤이안나)

- 🕒 **풀이 및 풀기 소요시간**: 1시간 20분
- 🔗 참고 블로그:
  1. https://velog.io/@rkio/백준-Javascript-1158
  2. https://junghyeonsu.tistory.com/241

**리뷰**  
앞선 1920문제보다 흐름은 조금 더 이해가 되는 것 같았다.  
두 개의 블로그 코드를 뜯어보며 대충 이해하고,  
GPT에게 내가 이해하기 쉬운 코드로 설명해달라고 요청했다.

**회고**

- 문제 풀이 및 시간을 줄이기 위해 이해하기 쉬운 코드를 뜯어서 글로 적음
- 문제를 다시 보고, 이해한 내용을 바탕으로 정리하며 풀기 완성
- 아직 아예 안 보고 풀긴 어렵지만,열심히 하자
