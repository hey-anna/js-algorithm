# 코드 뜯어서 설명

아래 코드를 **입력 파싱 → 변수 설정 → 반복(역연산) → 최종 비교** 흐름으로 한 줄씩 뜯어 설명합니다.

```js
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");

const S = input[0];
let T = input[1];

while (T.length > S.length) {
  if (T.endsWith("A")) {
    T = T.slice(0, -1); // A 제거
  } else if (T.endsWith("B")) {
    T = T.slice(0, -1).split("").reverse().join(""); // B 제거 후 뒤집기
  }
}

console.log(T === S ? 1 : 0);
```

---

## 1) 입력 파싱

```js
const fs = require("fs");
```

- Node.js의 파일 시스템 모듈 불러오기 (표준입력 읽을 때 사용).

```js
const input = fs.readFileSync("/dev/stdin").toString().trim().split("\n");
```

- 온라인 저지(백준)에서 **표준입력 전체**를 읽음.
- `.toString()` : 버퍼 → 문자열.
- `.trim()` : 앞뒤 공백/개행 제거(테스트 케이스 끝의 빈 줄로 인한 오류 방지).
- `.split("\n")` : 줄 단위로 나눠 **배열**로 변환.
  - `input[0]` → 첫 줄(S), `input[1]` → 둘째 줄(T).

---

## 2) 핵심 변수 준비

```js
const S = input[0];
let T = input[1];
```

- `S`: 목표가 되는 시작 문자열(변하지 않음) → `const`.
- `T`: 역연산으로 계속 **줄여갈 대상** → 값이 변하므로 `let`.

---

## 3) 역연산 루프 (T → S로 줄이기)

```js
while (T.length > S.length) {
```

- **T가 S보다 길 때만** 줄여나감.
- 길이가 같아지면 더 줄이면 S보다 짧아져서 “같아질 가능성”이 사라짐 → 루프 종료.

```js
if (T.endsWith("A")) {
  T = T.slice(0, -1); // A 제거
}
```

- **T의 끝이 'A'**인 경우:
  - 정방향(S→T)에서 “A를 뒤에 붙였다”의 **역연산**은 “마지막 A 제거”.
  - `slice(0, -1)`: 마지막 문자 하나 제거.

```js
  else if (T.endsWith('B')) {
    T = T.slice(0, -1).split('').reverse().join(''); // B 제거 후 뒤집기
  }
```

- **T의 끝이 'B'**인 경우:
  - 정방향에서 “B를 붙이고 전체 뒤집기”를 했으므로,
  - 역연산은 **(1) 마지막 B 제거 → (2) 문자열 뒤집기**.
  - `slice(0, -1)`: 마지막 B 제거
  - `split('')`: 문자열 → 문자 배열
  - `reverse()`: 배열 뒤집기
  - `join('')`: 다시 문자열로 합치기  
    → 결국 “B 제거 후 뒤집기”가 한 줄로 구현됨.

> ✅ 이 두 분기 외의 케이스는 없음(문자는 A와 B만 주어짐).

---

## 4) 최종 판정

```js
console.log(T === S ? 1 : 0);
```

- 역연산을 끝까지 수행한 뒤 **T와 S가 완전히 동일**하면 `1`, 아니면 `0`.
- “동일”은 **길이/문자/순서 모두 동일**을 의미.

---

## 🔍 동작 예시(간단 추적)

- 입력
  ```
  S = "B"
  T = "ABBA"
  ```
- 루프
  - `"ABBA"` (끝 A) → `"ABB"`
  - `"ABB"` (끝 B) → `"BA"` // B 제거 후 뒤집기
  - `"BA"` (끝 A) → `"B"`
- 길이 같아짐 → 비교: `"B" === "B"` → `1` 출력

---

## ⏱️ 시간·공간 복잡도

- 최악의 경우 T의 길이(최대 1000)를 한 글자씩 줄이므로 **O(|T|)** 반복.
- 각 반복에서 뒤집기(`split+reverse+join`)가 **O(현재 길이)**이지만 길이가 줄어듦.
- 전체적으로 **O(|T|²)** 상한으로 보아도 |T| ≤ 1000이면 충분히 통과(실제론 더 빠름).
- 공간은 문자열 복사/뒤집기 비용 외 추가 구조 없음 → **O(|T|)** 정도.

---

## ⚠️ 자주 하는 실수

- **정방향(S→T)으로 BFS/DFS** 시도 → 경우의 수 폭발.
- **루프 종료 조건 누락**: `while (T.length > S.length)`가 핵심.
- **뒤집기 순서 오류**: B 처리 시 “제거 후 뒤집기” 순서가 바뀌면 틀림.
- **입력 공백 처리** 빼먹음 → `.trim()` 필수.

---

## 🧪 디버깅 팁 (중간 상태 확인)

```js
// while 내부에 임시로 넣어보세요
// console.log('curr T =', T);
```
