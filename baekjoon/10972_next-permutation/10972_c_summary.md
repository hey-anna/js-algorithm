# BOJ 10972 - 다음 순열 - 문제 요약

## 📈 next permutation 압축 요약

| 파트           | 설명                                         |
| -------------- | -------------------------------------------- |
| `i 찾기`       | 뒤에서부터 처음으로 **감소가 시작되는 지점** |
| `j 찾기`       | `i-1`보다 큰 수 중 가장 끝에 있는 수         |
| `swap`         | `i-1` ↔ `j`                                  |
| `slice + sort` | 뒷부분 정렬해서 가장 작은 순열로 만들기      |

## 📈 next permutation 흐름 요약

| 단계  | 설명                                          | 예시 (`[1, 2, 3, 4]`)                     |
| ----- | --------------------------------------------- | ----------------------------------------- |
| 0단계 | 기준점이 없다면 (`i === 0`) → 마지막 순열이다 | 예: `[4, 3, 2, 1]` → `-1` 출력            |
| 1단계 | i 찾기 (기준점)                               | i = 3 (arr[2] = 3 < arr[3] = 4)           |
| 2단계 | j 찾기 (기준보다 큰 수)                       | j = 3 (arr[3] = 4)                        |
| 3단계 | swap(arr[i - 1], arr[j])                      | → `[1, 2, 4, 3]`                          |
| 4단계 | i부터 끝까지 오름차순 정렬                    | i=3 이후 [3] 정렬 → 그대로 `[1, 2, 4, 3]` |

✅ 결론
기준점을 찾는다 → 그보다 큰 값을 찾아 바꾼다 →
남은 뒤쪽은 가장 작은 순으로 정렬한다
→ 이 세 단계로 **"다음 순열"**이 완성됩니다! ✅

## 🔄 next permutation 시각적 흐름도 (도식 버전)

```
[입력된 순열]
  예: [1, 2, 3, 4]

      ↓

(1) 기준점 i 찾기  ← ← ← ← ← ←
    arr[i - 1] < arr[i] 를 만족하는 가장 마지막 i
    ✔️ 기준점 발견 시 → 다음 단계 진행
    ❌ 기준점이 없으면 (완전 내림차순) → -1 출력 후 종료
            예: [4, 3, 2, 1]
                    ↓
               i === 0 → -1

      ↓

(2) 기준점 arr[i - 1]보다 큰 수 j 찾기 (맨 뒤에서부터)
    조건: arr[j] > arr[i - 1]
    → 가장 오른쪽의 큰 수를 찾아야 "가장 작게 커짐"

      ↓

(3) swap(arr[i - 1], arr[j])
    → 둘을 교환해서 기준점을 한 단계 키움
    예: [1, 2, 3, 4] → swap(3, 4) → [1, 2, 4, 3]

      ↓

(4) i부터 끝까지 오름차순 정렬
    → 뒷부분을 가장 작은 형태로 바꾸기 위해 정렬
    예: [1, 2, 4, 3] → i=3 이후는 [3] → 그대로 유지

      ↓

[출력]
    ✅ 다음 순열 출력!
    예: 1 2 4 3
```
