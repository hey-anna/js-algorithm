## ✅ 백준 10972 - 다음 순열 (Next Permutation) 완전 정리

### 🎯 문제 목적

> 주어진 순열보다 **사전 순으로 조금 더 큰 순열**을 구하는 문제  
> 없으면 `-1` 출력

---

### 📌 예시

가능한 순열 (1 ~ 3):

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

- 입력이 `1 3 2`면 → 다음 순열: `2 1 3`
- 입력이 `3 2 1`이면 → 마지막 순열 → 출력: `-1`

---

### 🧠 핵심 아이디어: next permutation 알고리즘

> 지금보다 **조금 더 큰 수를 만들되, 가장 작게**

---

### 🔁 풀이 단계

#### ✔️ Step 1. 기준점(i) 찾기

- 뒤에서부터 왼쪽으로 탐색
- **처음으로 앞이 뒤보다 작은 위치 `i-1` 찾기**
  - 즉, `arr[i - 1] < arr[i]` 만족
  - 이게 "기준점"

예: `1 2 3 5 4` → `3 < 5` → `i = 3` (기준: 3)

---

#### ✔️ Step 2. 바꿀 대상(j) 찾기

- 다시 뒤에서부터 탐색
- **arr[i - 1]보다 큰 값 중 가장 뒤에 있는 값 `j` 찾기**
- `arr[i - 1]`과 `arr[j]`를 **swap**

예: `3`과 `4`를 swap → `1 2 4 5 3`

---

#### ✔️ Step 3. 기준 이후 정렬

- `i`부터 끝까지는 **항상 내림차순**
- 정렬 or 뒤집기 → **오름차순으로 바꿔주기**

최종: `1 2 4 3 5`

---

### ❌ 예외: 마지막 순열인 경우

- `arr`이 전체 내림차순이면 → `i`를 찾지 못함
- 즉, `i === 0` → 이미 마지막 순열  
  → 출력: `-1`

---

### 📦 요약 도식

입력: `[1, 2, 3, 5, 4]`

1. 기준점: 3 (i = 3) → `3 < 5`
2. 뒤에서 3보다 큰 수 찾기: `4`
3. swap(3, 4) → `[1, 2, 4, 5, 3]`
4. i 이후 정렬 → `[1, 2, 4, 3, 5]` → 정답

---

### 📌 결론

- 사전 순으로 한 칸만 이동하는 알고리즘
- 모든 순열을 만드는 방식 ❌ (비효율적)
- **뒤에서부터 관찰 → 기준점 찾고 → 스왑 + 정렬**

```js
// arr = [1, 2, 3, 5, 4]
// 결과: [1, 2, 4, 3, 5]
```

---
