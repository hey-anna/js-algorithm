# BOJ 11404 - 플로이드 - 최소 비용 경로 찾기 - 코드 흐름

### 입력 예시

```
도시 수 (n): 4
버스 정보 (m): 4
버스 노선 (단반향):
1 2 4
1 3 2
2 3 5
3 4 1
```

1 → 2 (4)
1 → 3 (2)
2 → 3 (5)
3 → 4 (1)

---

### ✅ 1단계: 거리 배열 초기화

- `dist[i][j] = ∞` 로 시작 (도달할 수 없음)
- `dist[i][i] = 0` (자기 자신은 비용 0)

📌 초기 상태:

```
[0   ∞   ∞   ∞] // 1번 도시
[∞   0   ∞   ∞] // 2번 도시
[∞   ∞   0   ∞] // 3번 도시
[∞   ∞   ∞   0] // 4번 도시
```

---

### ✅ 2단계: 입력된 간선 정보 반영

- 간선이 존재하는 경우 `dist[from][to] = cost`
- 같은 from→to가 여러 번 있을 경우, **더 싼 비용만 유지**

📌 반영 후:

```
[0   4   2   ∞] // 1 → 2 (4), 1 → 3 (2)
[∞   0   5   ∞] // 2 → 3 (5)
[∞   ∞   0   1] // 3 → 4 (1)
[∞   ∞   ∞   0]
```

---

### ✅ 3단계: 경유지 `k`를 기준으로 최단거리 갱신

#### k = 1:

- i → 1 → j 경로 탐색

> 1번 도시를 경유지로 ?
> 1 → 2 → 3: 1 → 2 (4), 2 → 3 (5) → 합쳐서 9
> → 하지만 기존 dist[1][3] = 2 이므로 갱신 안 함
> 1 → 3 → 4: 아직 3 → 4 는 갱신 안 됨

> 변화 없음

#### k = 2:

- i → 2 → j 경로 탐색

> 2번 도시 경유 ?
> 1 → 2 → 3 = 1 → 2 (4), 2 → 3 (5) → 거리 9
> → 기존 1 → 3 은 2 → 갱신 안함

> 변화 없음

#### k = 3:

- `1 → 3 → 4 = 2 + 1 = 3` → 갱신
- `2 → 3 → 4 = 5 + 1 = 6` → 갱신

> 1 → 3 → 4 = 1 → 3 (2), 3 → 4 (1) = 총 3
> → dist[1][4] = ∞ → 3 으로 갱신 ✅

> 2 → 3 → 4 = 2 → 3 (5), 3 → 4 (1) = 총 6
> → dist[2][4] = ∞ → 6 으로 갱신 ✅

📌 갱신 결과:

```
[0   4   2   3]
[∞   0   5   6]
[∞   ∞   0   1]
[∞   ∞   ∞   0]
```

#### k = 4:

- 변화 없음 (4는 출발 노선이 없음)
  > 노선없어서 시도 안함

---

### ✅ 4단계: 출력 준비

- 도달 불가한 곳 (`∞`)은 `0`으로 출력
- 자기 자신은 항상 0

📌 최종 출력:

```
0 4 2 3
0 0 5 6
0 0 0 1
0 0 0 0
```

---

### 핵심 포인트 요약

- `dist[i][j]`는 i → j로 가는 **최소 비용**
- `dist[i][i] = 0`, `도달 불가 = 0(출력 전 변환)`
- 모든 도시 쌍에 대해 최소 비용 계산
- 중복 노선은 더 싼 비용만 유지
- 우회 경로가 더 싸면 그것으로 갱신
