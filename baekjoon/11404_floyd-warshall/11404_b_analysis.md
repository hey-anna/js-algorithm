# BOJ 11404 - 플로이드 - 문제 해석

# 문제 풀이

- n개의 도시
- 도시 x → 도시 y = m개의 버스
- 각 버스는 한 번 사용할 때 필요한 비용이 있음

> 모든 도시의 쌍 (A, B)에 대해서
> A에서 B로 가는데 필요한 비용의 **최솟값을 구하는 문제**

- 여러 도시가 있고, **일방통행 버스(a→b, 비용 c)** 들이 주어질 때, **모든 도시쌍 (i, j)** 사이의 **최소 이동 비용**을 표로 출력하는 문제.

## 입력

- 첫째줄 : 도시의 개수 : n
- 둘째줄 : 버스의 개수 : m
- 셋째줄 : 버스의 정보 : m + 2

### 버스의 정보

- a : 시작 도시(버스의)
- b : 도착 도시
- c : 이동 비용(한 번 타는데 필요한 비용)

### 유의 사항

- 시작 도시와 도착 도시가 같은 경우는 없다.
- **a → b 간선이 여러 개 존재 가능** (시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.)
  → 이때는 **가장 작은 비용만 유지해야 함** (비용은 100,000보다 작거나 같은 자연수이다.)
- 양방향이라고 문제에 명시되어 있지않으면 단방향으로 처리해야 한다.

## 출력

- n개의 줄을 출력해야 한다
- i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다.
- 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.

## 예제 입력

```
5     : 도시 수 (N)
14    : 버스 정보 개수 (M)
1 2 2 : 1번 도시 → 2번 도시, 비용 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1 **
4 5 3
3 5 10 **
3 1 8
1 4 2
5 1 7
3 4 2
5 2 4
```

## 예제 출력

0 2 3 1 4
12 0 15 2 5
8 5 0 1 1
10 7 13 0 3
7 4 10 6 0

## 💡 핵심 풀이 아이디어

- 모든 쌍 (i → j) 최단 경로 = **플로이드-워셜 알고리즘**
- 3중 for문 (k → i → j)
  - `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`
- `dist[i][i] = 0`, 나머지 초기값은 **무한대**
- 중복 간선은 **입력 받을 때 min 처리**
- 출력 시 도달 불가면 **0으로 변환**
