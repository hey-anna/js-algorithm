# BOJ 2164 - 카드2 - 문제 해석

## 문제 해석

총 N장의 카드가 1번부터 N번까지 순서대로 쌓여 있으며, 1번이 제일 위에, N번이 제일 아래에 위치한 상태로 시작한다. 이 상태에서 아래와 같은 두 가지 동작을 반복한다:

1. 제일 위의 카드를 버린다.
2. 그 다음 제일 위에 있는 카드를 맨 아래로 옮긴다.

이 과정을 카드가 한 장만 남을 때까지 반복하며, **마지막에 남는 카드 번호를 출력**하는 것이 목표다.

### 예시:

`N = 6`인 경우  
초기 상태: `[1, 2, 3, 4, 5, 6]`

- 1 버림 → [2, 3, 4, 5, 6]
- 2 아래로 → [3, 4, 5, 6, 2]
- 3 버림 → [4, 5, 6, 2]
- 4 아래로 → [5, 6, 2, 4]
- 5 버림 → [6, 2, 4]
- 6 아래로 → [2, 4, 6]
- 2 버림 → [4, 6]
- 4 아래로 → [6, 4]
- 6 버림 → [4]

마지막에 남는 카드: **4**

## 입력

- 첫째 줄에 정수 N (1 ≤ N ≤ 500,000)이 주어진다.

## 출력

- 마지막에 남는 카드 번호를 출력한다.

## 풀이 키포인트

- FIFO(First-In-First-Out) 구조인 **큐(Queue)**를 활용해 구현한다.
- Python에서는 `collections.deque` 사용 시 pop/append 연산을 O(1)로 처리할 수 있어 효율적이다.
