# BOJ 2164 - 카드2 - 풀이 설명

---

## 🔹 초기 상태

```js
const N = 6;
const queue = [1, 2, 3, 4, 5, 6];
let head = 0;
let tail = N; // 6
```

- `head` → 현재 맨 앞 카드 위치 (`queue[0] = 1`)
- `tail` → 다음 들어갈 빈 칸 위치 (`queue[6]` 비어 있음)
  - 즉, `queue[6]`부터는 카드가 없고, **새롭게 추가될 위치**

---

## 🔹 흐름 시뮬레이션 (한 줄씩 뜯어보기)

### 1️⃣ 카드 버리기

```js
head++;
```

- `head`가 0 → 1로 이동
- 즉, `queue[0] = 1`은 더 이상 접근하지 않음 → **버린 것처럼 작동**

---

### 2️⃣ 카드 뒤로 보내기

```js
queue[tail++] = queue[head++];
```

- 오른쪽 먼저 실행 → `queue[head++]`

  - 현재 `head = 1` → `queue[1] = 2`
  - `2`를 꺼내고 `head`는 2로 증가

- 왼쪽에 할당 → `queue[tail++] = 2`
  - 현재 `tail = 6` → `queue[6] = 2`
  - 그 후 `tail`은 7로 증가

```txt
결과 상태:
queue = [1, 2, 3, 4, 5, 6, 2]
head = 2
tail = 7
```

---

## 🧠 동작 원리 정리

| 코드 구문                       | 의미                                     |
| ------------------------------- | ---------------------------------------- |
| `head++`                        | 앞 카드 버림 (queue[head]는 앞으로 무시) |
| `queue[tail++] = queue[head++]` | 다음 카드 꺼내서 맨 뒤에 추가            |

- 실제 배열에서 삭제는 일어나지 않음
- 하지만 포인터 이동만으로 **큐처럼 동작**
- `shift()`보다 훨씬 효율적 (시간 초과 방지)

---

## ✅ 결론

이 방식은 배열을 직접 삭제하거나 새로 만들지 않고,  
`head`, `tail` 포인터만 조작해서 **큐의 동작을 시뮬레이션**하는 전형적인 기법이다.  
이 로직을 `tail - head > 1`일 동안 반복하면,  
**마지막 한 장만 남게 되는 구조**를 효율적으로 구현할 수 있다.
