## 🔍 isPrime 배열 - 실제 모습 도식화 (예: N = 16)

### ✅ 초기 상태 (`fill(true)` 적용 후)

| 인덱스(i) | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
| --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| isPrime   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   | T   |

- 모든 수를 일단 **소수(true)**라고 가정

---

### ✅ 0과 1은 소수가 아니므로 false 처리

```js
isPrime[0] = isPrime[1] = false;
```

| 인덱스(i) | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
| --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| isPrime   | ❌  | ❌  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  | ✅  |

---

### ✅ i = 2 → 2의 배수들 제거 (4, 6, 8, 10, 12, 14, 16)

```js
for (let j = i*i; j <= N; j += i)
```

| 인덱스(i) | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
| --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| isPrime   | ❌  | ❌  | ✅  | ✅  | ❌  | ✅  | ❌  | ✅  | ❌  | ✅  | ❌  | ✅  | ❌  | ✅  | ❌  | ✅  | ❌  |

---

### ✅ i = 3 → 3의 배수들 제거 (9, 12, 15)

```js
for (let j = 9; j <= 16; j += 3)
```

| 인덱스(i) | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  |
| --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| isPrime   | ❌  | ❌  | ✅  | ✅  | ❌  | ✅  | ❌  | ✅  | ❌  | ❌  | ❌  | ✅  | ❌  | ✅  | ❌  | ❌  | ❌  |

---

### ✅ 최종 결과: isPrime[i]가 true인 i만 소수!

```
소수 목록: 2, 3, 5, 7, 11, 13
```

---

> ✅ 이렇게 `isPrime` 배열을 통해 소수를 걸러내는 게  
> 바로 에라토스테네스의 체의 핵심이에요!
